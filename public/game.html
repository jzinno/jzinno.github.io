<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Slurm Scheduler: The Game</title>
    <style>
        :root {
            --bg: #0f1115;
            --panel: #15181f;
            --panel-alt: #101218;
            --border: #2c303a;
            --border-strong: #5a6375;
            --text: #e7e9ee;
            --muted: #a5adbd;
            --accent: #a3e4d7;     /* pastel mint */
            --accent-2: #f2c6de;   /* pastel pink */
            --danger: #f28b82;     /* soft coral */
            --queue-line: #8f99ad;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: 'Courier New', Courier, monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
            overflow: hidden;
            user-select: none;
        }

        h1 { margin-bottom: 10px; color: var(--accent); text-shadow: 0 0 8px var(--accent); letter-spacing: 1px; }

        #top-bar {
            display: flex;
            align-items: center;
            gap: 10px;
            width: 100%;
            max-width: 900px;
            margin-bottom: 10px;
        }

        #game-ui {
            display: flex;
            justify-content: space-between;
            flex: 1;
            gap: 8px;
            font-size: 14px;
        }

        .stat-box {
            background: linear-gradient(145deg, var(--panel), var(--panel-alt));
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 6px;
            flex: 1;
            margin: 0 5px;
            text-align: center;
            box-shadow: 0 8px 20px rgba(0,0,0,0.25);
        }

        .value { font-size: 18px; font-weight: bold; color: #fff; }

        canvas {
            background: radial-gradient(circle at 20% 20%, #0d1118, #0a0c12);
            border: 2px solid var(--border-strong);
            box-shadow: 0 0 25px rgba(0,0,0,0.55), inset 0 0 25px rgba(163,228,215,0.08);
            border-radius: 10px;
            cursor: crosshair;
        }

        button {
            background: transparent;
            border: 1px solid var(--border-strong);
            padding: 10px 18px;
            color: var(--text);
            font-weight: bold;
            font-family: inherit;
            cursor: pointer;
            border-radius: 6px;
            transition: all 0.15s ease;
            box-shadow: 0 6px 14px rgba(0,0,0,0.25);
        }
        button:hover { background: rgba(163,228,215,0.18); color: #fff; }

        .control-btn { white-space: nowrap; }

    </style>
</head>
<body>

    <h1>I AM SLURM</h1>

    <div style="display:flex; gap:8px; align-items:center; margin-bottom:8px; color:var(--muted); font-size:12px;">
        <span>Seed:</span>
        <input id="seed-input" style="background:var(--panel); border:1px solid var(--border); color:var(--text); padding:4px 6px; border-radius:4px; width:120px;" />
        <button class="control-btn" onclick="applySeedFromInput()" style="padding:6px 10px;">Set</button>
        <button class="control-btn" onclick="randomizeSeed()" style="padding:6px 10px;">Randomize</button>
    </div>


    <div id="top-bar">
        <button class="control-btn" onclick="startGame()">START ROUND</button>
        <div id="game-ui">
            <div class="stat-box">
                <div>JOBS LEFT</div>
                <div id="jobs-left" class="value">0</div>
            </div>
            <div class="stat-box">
                <div>AVG WAIT</div>
                <div id="avg-wait" class="value">0.0s</div>
            </div>
            <div class="stat-box">
                <div>OCCUPANCY</div>
                <div id="occupancy" class="value">0%</div>
            </div>
            <div class="stat-box">
                <div>GOLD</div>
                <div id="gold" class="value">0</div>
            </div>
        </div>
        <button class="control-btn" onclick="newGame()">NEW GAME</button>
    </div>


    <canvas id="gameCanvas" width="600" height="700"></canvas>

    <div id="gameover-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.65); align-items:center; justify-content:center;">
        <div style="background:linear-gradient(145deg,#15181f,#101218); border:1px solid var(--border-strong); padding:18px; border-radius:12px; width:340px; box-shadow:0 0 24px rgba(0,0,0,0.55); color:var(--text); text-align:center;">
            <div style="font-weight:bold; margin-bottom:8px; color:var(--accent-2);">Game Over</div>
            <div id="gameover-info" style="color:var(--muted); font-size:13px; margin-bottom:12px; white-space:pre-line;"></div>
            <button class="control-btn" onclick="newGame()">NEW GAME</button>
        </div>
    </div>

    <div id="shop-modal" style="display:none; position:fixed; inset:0; background:rgba(0,0,0,0.6); align-items:center; justify-content:center;">
        <div id="shop-box" style="background:linear-gradient(145deg,#15181f,#101218); border:1px solid var(--border-strong); padding:16px; border-radius:10px; width:360px; box-shadow:0 0 22px rgba(0,0,0,0.55);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:10px;">
                <div style="color:var(--text); font-weight:bold;">Node Shop</div>
                <div style="display:flex; gap:6px;">
                    <button id="reroll-shop" onclick="rerollShop()" style="background:transparent; color:var(--text); padding:6px 10px; border:1px solid var(--border-strong); border-radius:6px; cursor:pointer;">Reroll (-10g)</button>
                    <button id="close-shop" onclick="leaveShop()" style="background:transparent; color:var(--text); padding:6px 10px; border:1px solid var(--border-strong); border-radius:6px; cursor:pointer;">Leave</button>
                </div>
            </div>
            <div id="shop-info" style="color:var(--muted); font-size:12px; margin-bottom:8px;">Drag a node to the cluster edge to attach. Cost: 10 gold per core.</div>
            <div id="shop-items" style="display:flex; gap:10px; justify-content:space-between;"></div>
        </div>
    </div>

<script>
    /** 
     * CONFIGURATION 
     */
    const CANVAS_MIN_WIDTH = 600;
    const CANVAS_MIN_HEIGHT = 700;
    let CANVAS_WIDTH = CANVAS_MIN_WIDTH;
    let CANVAS_HEIGHT = CANVAS_MIN_HEIGHT;
    
    // Cluster Layout
    const START_NODES = 3;             // starting nodes
    const BASE_NODE_SIZE = 80;         // preferred pixel size per core
    const MIN_NODE_SIZE = 40;          // minimum pixel size per core when scaling down
    let NODE_SIZE = BASE_NODE_SIZE;    // current pixel size per core (responsive)
    const GRID_TOP = 50;
    const QUEUE_MARGIN = 60;
    const QUEUE_HEIGHT = 200;          // vertical space reserved for queue/pending jobs
    const BOTTOM_PADDING = 140;        // extra space below queue for comfort on tall clusters
    const TRASH_WIDTH = 90;
    const TRASH_HEIGHT = 50;
    const TRASH_MARGIN = 20;
    const NODE_COST = 10;              // gold required per core (area unit)
    const PREVIEW_BUFFER = 4;          // extra cores beyond current grid to allow placement preview/attachment
    const GAME_OVER_WAIT = 8.0;        // seconds; if avg wait exceeds, trigger game over
    let seed = Math.floor(Math.random() * 1e9);
    let displaySeed = seed.toString();

    // Difficulty scaling per round
    const BASE_JOBS_PER_ROUND = 10;
    const JOBS_PER_ROUND_INCREMENT = 4; // jobs added each round
    const BASE_SPAWN_RATE = 120;        // frames between spawns, round 1
    const SPAWN_RATE_ACCELERATION = 5; // frames removed each round
    const MIN_SPAWN_RATE = 60;          // floor on spawn interval

    let nodes = []; // each: {x,y,w,h} in core units
    let totalNodes = START_NODES;
    let GRID_COLS = 0;          // total core columns
    let GRID_ROWS = 0;          // total core rows
    let TOTAL_BLOCKS = 0;
    let GRID_OFFSET_X = 0;
    let GRID_OFFSET_Y = GRID_TOP;

    // Queue Layout
    let QUEUE_Y = 450;
    
    // Game Settings
    const JOBS_PER_ROUND = 20;
    const SPAWN_RATE = 150; // Frames between spawns

    // Colors
    let COLORS = ['#f7768e', '#ff9e64', '#e0af68', '#9ece6a', '#7dcfff', '#bb9af7'];

    /**
     * STATE
     */
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    const shopModal = document.getElementById('shop-modal');
    const shopItemsEl = document.getElementById('shop-items');
    const closeShopBtn = document.getElementById('close-shop');

    let shopItems = [];
    let draggingShopItem = null;
    let dragGhost = null;
    let shopPreview = null;
    let gameLost = false;
    let totalGoldEarned = 0;
    let runSeedDisplay = displaySeed;

    let roundNumber = 1;
    let jobsPerRound = BASE_JOBS_PER_ROUND;
    let spawnRate = BASE_SPAWN_RATE;
    let jobs = []; // Jobs in queue or dragging
    let activeJobs = []; // Jobs currently running on cluster
    let finishedJobs = [];
    let jobsSpawned = 0;
    let frameCount = 0;
    let isGameOver = true;
    let gold = 0;
    let totalWaitPenaltyMs = 0;
    let animationId = null;
    
let dragJob = null;
let dragOffsetX = 0;
let dragOffsetY = 0;
const seedInput = document.getElementById('seed-input');
seedInput.value = displaySeed;

    // Statistics
    let totalOccupancySamples = 0;
    let accumulatedOccupancy = 0;

    function repositionPendingJobs() {
        jobs.forEach(job => {
            job.x = 50 + (seededRand() * (CANVAS_WIDTH - 150));
            job.y = QUEUE_Y + 50 + (seededRand() * 100);
        });
    }

    function updateGridFromNodes() {
        if (nodes.length === 0) {
            GRID_COLS = 0;
            GRID_ROWS = 0;
            TOTAL_BLOCKS = 0;
            totalNodes = 0;
            return;
        }
        let maxX = 0;
        let maxY = 0;
        nodes.forEach(n => {
            maxX = Math.max(maxX, n.x + n.w);
            maxY = Math.max(maxY, n.y + n.h);
        });
        GRID_COLS = maxX;
        GRID_ROWS = maxY;
        TOTAL_BLOCKS = nodes.reduce((sum, n) => sum + n.w * n.h, 0);
        totalNodes = nodes.length;
    }

    function isNodeOwnedCore(row, col) {
        return nodes.some(n => col >= n.x && col < n.x + n.w && row >= n.y && row < n.y + n.h);
    }

    function findContainingNode(col, row, w, h) {
        return nodes.find(n => (
            col >= n.x && row >= n.y &&
            (col + w) <= (n.x + n.w) &&
            (row + h) <= (n.y + n.h)
        ));
    }

    function recomputeLayout() {
        const topBar = document.getElementById('top-bar');
        const topH = topBar ? topBar.offsetHeight : 0;
        const reservedVertical = GRID_TOP + QUEUE_MARGIN + QUEUE_HEIGHT + BOTTOM_PADDING + topH + 40; // queue space + padding
        const availableWidth = window.innerWidth - 120;
        const availableHeight = window.innerHeight - reservedVertical;

        if (GRID_COLS === 0 || GRID_ROWS === 0) {
            NODE_SIZE = BASE_NODE_SIZE;
        } else {
            const fitWidth = Math.floor(availableWidth / GRID_COLS);
            const fitHeight = Math.floor(availableHeight / GRID_ROWS);
            NODE_SIZE = Math.max(10, Math.min(BASE_NODE_SIZE, fitWidth, fitHeight));
        }

        const gridPixelWidth = GRID_COLS * NODE_SIZE;
        const gridPixelHeight = GRID_ROWS * NODE_SIZE;

        CANVAS_WIDTH = Math.max(CANVAS_MIN_WIDTH, gridPixelWidth + 120);
        CANVAS_HEIGHT = Math.max(CANVAS_MIN_HEIGHT, GRID_TOP + gridPixelHeight + QUEUE_MARGIN + QUEUE_HEIGHT + BOTTOM_PADDING);
        GRID_OFFSET_X = (CANVAS_WIDTH - gridPixelWidth) / 2;
        GRID_OFFSET_Y = GRID_TOP;
        QUEUE_Y = GRID_OFFSET_Y + gridPixelHeight + QUEUE_MARGIN;

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;

        repositionPendingJobs();
    }

    function initNodes() {
        nodes = [
            {x:0, y:0, w:4, h:2},
            {x:0, y:2, w:2, h:2},
            {x:2, y:2, w:2, h:2},
        ];
        updateGridFromNodes();
        recomputeLayout();
    }

    // Initial layout sizing and HUD seed
    initNodes();
    document.getElementById('gold').innerText = gold;
    seedInput.value = seed.toString();

    class Job {
        constructor(id) {
            this.id = id;
            // Random Dimensions (scales up after round 2, but still includes smaller shapes)
            const allowLarge = roundNumber >= 3;
            const rand = seededRand();
            const bigChance = allowLarge ? 0.1 : 0.0;
        const bigRoll = seededRand();
        if (allowLarge && bigRoll < bigChance) {
            // Rare big shapes added to the pool
            const bigRand = seededRand();
            if (bigRand < 0.33) { this.w = 3; this.h = 2; }
            else if (bigRand < 0.66) { this.w = 2; this.h = 3; }
            else { this.w = 3; this.h = 3; }
        } else {
            const rand = seededRand();
            if (rand < 0.5) {
                this.w = 1; this.h = 1;
            } else if (rand < 0.7) {
                this.w = 2; this.h = 1;
            } else if (rand < 0.9) {
                    this.w = 1; this.h = 2;
                } else {
                    this.w = 2; this.h = 2;
                }
            }

            // Duration: 300 to 1200 frames (5 to 20 seconds approx)
            this.maxDuration = 300 + seededRand() * 900;
            this.duration = this.maxDuration;
            
            // Visuals
            this.color = COLORS[Math.floor(seededRand() * COLORS.length)];
            
            // Position (in Queue initially)
            this.x = 50 + (seededRand() * (CANVAS_WIDTH - 150));
            this.y = QUEUE_Y + 50 + (seededRand() * 100);
            
            // Grid Position (if placed)
            this.gridX = -1;
            this.gridY = -1;

            // Stats
            this.arrivalTime = Date.now();
            this.startTime = null;
            this.finishTime = null;
        }

        draw(ctx) {
            // "Jelly" effect: Slight pulsation if waiting, solid if running
            let pulse = 0;
            if(!this.startTime && this !== dragJob) {
                pulse = Math.sin(Date.now() / 200) * 2;
            }

            const drawW = (this.w * NODE_SIZE) - 10 + pulse;
            const drawH = (this.h * NODE_SIZE) - 10 + pulse;

            ctx.fillStyle = this.color;
            ctx.globalAlpha = 0.8;
            
            // If running, darken based on progress
            if(this.startTime) {
                const progress = this.duration / this.maxDuration;
                ctx.globalAlpha = 0.4 + (progress * 0.5); // Fade out as it completes
                
                // Draw progress bar inside
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.roundRect(this.x, this.y, drawW, drawH * progress, 10);
                ctx.fill();
                
                // Outline
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 2;
                ctx.strokeRect(this.x, this.y, drawW, drawH);
            } else {
                // Just a jelly block
                ctx.beginPath();
                ctx.roundRect(this.x - (pulse/2), this.y - (pulse/2), drawW, drawH, 15);
                ctx.fill();
                ctx.strokeStyle = '#ffffffaa';
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            // Text info
            ctx.fillStyle = '#fff';
            ctx.globalAlpha = 1;
            ctx.font = '12px Arial';
            if(!this.startTime) {
                ctx.fillText(`${this.w}x${this.h}`, this.x + 10, this.y + 20);
            }
        }
    }

    function startGame() {
        if (gameLost) return;
        if (!isGameOver) return; // avoid double-starting while a round runs
        if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
        }
        runSeedDisplay = displaySeed; // snapshot for this run
        closeShop();
        updateGridFromNodes();
        jobsPerRound = BASE_JOBS_PER_ROUND + (roundNumber - 1) * JOBS_PER_ROUND_INCREMENT;
        spawnRate = Math.max(MIN_SPAWN_RATE, BASE_SPAWN_RATE - (roundNumber - 1) * SPAWN_RATE_ACCELERATION);
        dragJob = null;
        jobs = [];
        activeJobs = [];
        finishedJobs = [];
        jobsSpawned = 0;
        frameCount = 0;
        totalOccupancySamples = 0;
        accumulatedOccupancy = 0;
        totalWaitPenaltyMs = 0;
        shopPreview = null;
        recomputeLayout();
        isGameOver = false;
        document.getElementById('gold').innerText = gold;
        document.getElementById('jobs-left').innerText = jobsPerRound;
        document.getElementById('avg-wait').innerText = "0.0s";
        document.getElementById('occupancy').innerText = "0%";
        animationId = requestAnimationFrame(gameLoop);
    }

    function newGame() {
        isGameOver = true;
        gameLost = false;
        gold = 0;
        totalGoldEarned = 0;
        initNodes();
        updateGridFromNodes();
        roundNumber = 1;
        jobs = [];
        activeJobs = [];
        finishedJobs = [];
        jobsSpawned = 0;
        frameCount = 0;
        dragJob = null;
        totalOccupancySamples = 0;
        accumulatedOccupancy = 0;
        totalWaitPenaltyMs = 0;
        shopPreview = null;
        recomputeLayout();
        closeShop();
        document.getElementById('gameover-modal').style.display = 'none';
        document.getElementById('gold').innerText = gold;
        document.getElementById('jobs-left').innerText = 0;
        document.getElementById('avg-wait').innerText = "0.0s";
        document.getElementById('occupancy').innerText = "0%";
        startGame();
    }

    function spawnJob() {
        if (jobsSpawned < jobsPerRound) {
            jobs.push(new Job(jobsSpawned++));
        }
    }

    function updatePhysics() {
        if(isGameOver) return;

        // Spawn logic
        frameCount++;
        if (frameCount % spawnRate === 0) {
            spawnJob();
        }

        // Run Jobs
        for (let i = activeJobs.length - 1; i >= 0; i--) {
            let j = activeJobs[i];
            j.duration--;
            if (j.duration <= 0) {
                // Job Finished
                j.finishTime = Date.now();
                gold += 1; // 1 gold per completed job
                totalGoldEarned += 1;
                finishedJobs.push(j);
                activeJobs.splice(i, 1);
            }
        }

        // Calculate Stats
        const now = Date.now();
        
        // Occupancy (based on owned blocks)
        let usedBlocks = 0;
        activeJobs.forEach(j => usedBlocks += (j.w * j.h));
        const currentOcc = TOTAL_BLOCKS > 0 ? (usedBlocks / TOTAL_BLOCKS) : 0;
        
        accumulatedOccupancy += currentOcc;
        totalOccupancySamples++;
        
        const avgOcc = Math.round((accumulatedOccupancy / totalOccupancySamples) * 100);
        document.getElementById('occupancy').innerText = avgOcc + "%";
        document.getElementById('gold').innerText = gold;

        // Wait Time (sampled each frame; includes pending)
        let totalWait = 0;
        let count = 0;
        jobs.forEach(j => {
            totalWait += (now - j.arrivalTime);
            count++;
        });
        finishedJobs.forEach(j => {
            totalWait += (j.startTime - j.arrivalTime);
            count++;
        });
        activeJobs.forEach(j => {
            totalWait += (j.startTime - j.arrivalTime);
            count++;
        });
        const baseWait = count > 0 ? (totalWait / count / 1000) : 0;
        const penaltySeconds = totalWaitPenaltyMs / 1000;
        const avgWaitNum = baseWait + penaltySeconds;
        const avgWait = avgWaitNum.toFixed(1);
        document.getElementById('avg-wait').innerText = avgWait + "s";
        document.getElementById('jobs-left').innerText = (jobsPerRound - finishedJobs.length);
        if (!gameLost && avgWaitNum > GAME_OVER_WAIT) {
            gameLost = true;
            isGameOver = true;
            endGame(avgOcc, avgWait);
            return;
        }

        // Check End Condition
        if (jobsSpawned === jobsPerRound && jobs.length === 0 && activeJobs.length === 0) {
            isGameOver = true;
            const bonus = (20 * roundNumber) + avgOcc; // occupancy is already percent-rounded
            gold += bonus;
            totalGoldEarned += bonus;
            document.getElementById('gold').innerText = gold;
            roundNumber += 1;
            openShop(avgOcc, avgWait, bonus);
        }
    }

    function draw() {
        // Clear Background
        ctx.clearRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // 1. Draw Cluster (Hollow Shapes)
        ctx.strokeStyle = '#414868';
        ctx.lineWidth = 2;
        
        // Draw Label
        ctx.fillStyle = '#565f89';
        ctx.font = 'bold 16px Courier New';
        ctx.fillText(`CLUSTER RACK [${totalNodes} NODES, ${TOTAL_BLOCKS} CORES]`, GRID_OFFSET_X, GRID_OFFSET_Y - 15);

        // Draw nodes and their cores
        nodes.forEach(node => {
            const nodeX = GRID_OFFSET_X + (node.x * NODE_SIZE);
            const nodeY = GRID_OFFSET_Y + (node.y * NODE_SIZE);
            const nodeW = (node.w * NODE_SIZE) - 5;
            const nodeH = (node.h * NODE_SIZE) - 5;
            ctx.strokeStyle = '#a3e4d7';
            ctx.lineWidth = 4;
            ctx.shadowColor = 'rgba(163,228,215,0.25)';
            ctx.shadowBlur = 12;
            ctx.strokeRect(nodeX - 2, nodeY - 2, nodeW + 4, nodeH + 4);
            ctx.shadowBlur = 0;
            ctx.fillStyle = (node.x + node.y) % 2 === 0 ? 'rgba(26,29,38,0.8)' : 'rgba(21,24,32,0.8)';
            ctx.fillRect(nodeX - 2, nodeY - 2, nodeW + 4, nodeH + 4);

            for (let r = 0; r < node.h; r++) {
                for (let c = 0; c < node.w; c++) {
                    const x = nodeX + (c * NODE_SIZE);
                    const y = nodeY + (r * NODE_SIZE);
                    
                    ctx.fillStyle = '#171b24';
                    ctx.fillRect(x, y, NODE_SIZE - 5, NODE_SIZE - 5);
                    
                    ctx.strokeStyle = '#323846';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, NODE_SIZE - 5, NODE_SIZE - 5);
                    
                    ctx.beginPath();
                    ctx.arc(x + (NODE_SIZE-5)/2, y + (NODE_SIZE-5)/2, 6, 0, Math.PI*2);
                    ctx.fillStyle = '#1c2029';
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(x + (NODE_SIZE-5)/2, y + (NODE_SIZE-5)/2, 3, 0, Math.PI*2);
                    ctx.fillStyle = '#a3e4d7';
                    ctx.fill();
                }
            }
        });

        // 2. Draw Separator
        ctx.beginPath();
        ctx.moveTo(0, QUEUE_Y - 20);
        ctx.lineTo(CANVAS_WIDTH, QUEUE_Y - 20);
        ctx.strokeStyle = '#8f99ad';
        ctx.lineWidth = 2;
        ctx.setLineDash([8, 14]);
        ctx.stroke();
        ctx.setLineDash([]);
        
        ctx.fillStyle = '#2c303a';
        ctx.fillRect(16, QUEUE_Y - 36, 160, 20);
        ctx.fillStyle = '#e7e9ee';
        ctx.fillText("PENDING QUEUE", 24, QUEUE_Y - 21);

        // Trash Zone (bottom-right)
        const trashRect = getTrashRect();
        ctx.fillStyle = 'rgba(242,139,130,0.12)';
        ctx.strokeStyle = '#f28b82';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 10]);
        ctx.fillRect(trashRect.x, trashRect.y, trashRect.w, trashRect.h);
        ctx.strokeRect(trashRect.x, trashRect.y, trashRect.w, trashRect.h);
        ctx.setLineDash([]);
        ctx.fillStyle = '#f28b82';
        ctx.font = 'bold 10px Courier New';
        ctx.fillText("TRASH (+1s)", trashRect.x + 12, trashRect.y + trashRect.h/2 + 4);

        // 3. Draw Running Jobs
        activeJobs.forEach(job => {
            // Update visual position to match grid
            job.x = GRID_OFFSET_X + (job.gridX * NODE_SIZE);
            job.y = GRID_OFFSET_Y + (job.gridY * NODE_SIZE);
            job.draw(ctx);

            // Overlay a subtle hatch to reinforce occupancy
            ctx.fillStyle = 'rgba(15, 17, 22, 0.35)';
            for (let r = 0; r < job.h; r++) {
                for (let c = 0; c < job.w; c++) {
                    const x = job.x + c * NODE_SIZE;
                    const y = job.y + r * NODE_SIZE;
                    ctx.strokeStyle = 'rgba(227, 231, 238, 0.25)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + NODE_SIZE - 6, y + NODE_SIZE - 6);
                    ctx.stroke();
                }
            }
        });

        // 4. Draw Pending Jobs
        jobs.forEach(job => job.draw(ctx));

        // 5. Draw Dragged Job on top
        if (dragJob) {
            dragJob.draw(ctx);
            const snap = getGridSnap(dragJob.x, dragJob.y);
            const valid = snap && isValidPlacement(snap.c, snap.r, dragJob.w, dragJob.h);
            if(snap) {
                ctx.fillStyle = valid ? 'rgba(163,228,215,0.25)' : 'rgba(242,139,130,0.25)';
                ctx.strokeStyle = valid ? '#a3e4d7' : '#f28b82';
                ctx.lineWidth = 2;
                ctx.fillRect(
                    GRID_OFFSET_X + (snap.c * NODE_SIZE), 
                    GRID_OFFSET_Y + (snap.r * NODE_SIZE), 
                    dragJob.w * NODE_SIZE - 5, 
                    dragJob.h * NODE_SIZE - 5
                );
                ctx.strokeRect(
                    GRID_OFFSET_X + (snap.c * NODE_SIZE), 
                    GRID_OFFSET_Y + (snap.r * NODE_SIZE), 
                    dragJob.w * NODE_SIZE - 5, 
                    dragJob.h * NODE_SIZE - 5
                );
            }
        }

        // 6. Draw shop placement preview
        if (shopPreview) {
            ctx.fillStyle = shopPreview.valid ? 'rgba(163, 228, 215, 0.3)' : 'rgba(242, 139, 130, 0.35)';
            ctx.strokeStyle = shopPreview.valid ? '#a3e4d7' : '#f28b82';
            ctx.lineWidth = 2;
            ctx.fillRect(
                GRID_OFFSET_X + (shopPreview.col * NODE_SIZE),
                GRID_OFFSET_Y + (shopPreview.row * NODE_SIZE),
                shopPreview.w * NODE_SIZE,
                shopPreview.h * NODE_SIZE
            );
            ctx.strokeRect(
                GRID_OFFSET_X + (shopPreview.col * NODE_SIZE),
                GRID_OFFSET_Y + (shopPreview.row * NODE_SIZE),
                shopPreview.w * NODE_SIZE,
                shopPreview.h * NODE_SIZE
            );
        }
    }

    function gameLoop() {
        if (isGameOver) {
            animationId = null;
            return;
        }
        updatePhysics();
        draw();
        if (isGameOver) {
            animationId = null;
            return;
        }
        animationId = requestAnimationFrame(gameLoop);
    }

    /**
     * INTERACTION
     */
    function getGridSnap(x, y) {
        let testX = x - GRID_OFFSET_X + (NODE_SIZE/2);
        let testY = y - GRID_OFFSET_Y + (NODE_SIZE/2);
        
        let c = Math.floor(testX / NODE_SIZE);
        let r = Math.floor(testY / NODE_SIZE);

        if (c >= 0 && c < GRID_COLS + PREVIEW_BUFFER && r >= 0 && r < GRID_ROWS + PREVIEW_BUFFER) {
            return {c, r};
        }
        return null;
    }

    // Ensures a placement stays within a single owned node boundary
    function isWithinSingleOwnedNode(col, row, w, h) {
        return Boolean(findContainingNode(col, row, w, h));
    }

    function isValidPlacement(col, row, w, h) {
        // 1. Check Bounds
        if (col + w > GRID_COLS) return false;
        if (row + h > GRID_ROWS) return false;

        // 1b. Enforce node boundaries (jobs cannot span nodes)
        if (!isWithinSingleOwnedNode(col, row, w, h)) return false;

        // 2. Check Overlap with active jobs
        for (let job of activeJobs) {
            // AABB Collision
            // Existing job rect
            let r1 = {x: job.gridX, y: job.gridY, w: job.w, h: job.h};
            // Proposed rect
            let r2 = {x: col, y: row, w: w, h: h};

            if (r1.x < r2.x + r2.w &&
                r1.x + r1.w > r2.x &&
                r1.y < r2.y + r2.h &&
                r1.h + r1.y > r2.y) {
                return false;
            }
        }
        return true;
    }

    // Input Listeners
    canvas.addEventListener('mousedown', e => {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;

        // Check pending jobs (reverse order to grab top-most)
        for (let i = jobs.length - 1; i >= 0; i--) {
            let j = jobs[i];
            // Simple hit test
            if (mouseX >= j.x && mouseX <= j.x + (j.w * NODE_SIZE) &&
                mouseY >= j.y && mouseY <= j.y + (j.h * NODE_SIZE)) {
                
                dragJob = j;
                dragOffsetX = mouseX - j.x;
                dragOffsetY = mouseY - j.y;
                
                // Remove from pending list temporarily while dragging
                jobs.splice(i, 1);
                return;
            }
        }
    });

    canvas.addEventListener('mousemove', e => {
        if (dragJob) {
            const rect = canvas.getBoundingClientRect();
            dragJob.x = (e.clientX - rect.left) - dragOffsetX;
            dragJob.y = (e.clientY - rect.top) - dragOffsetY;
            draw();
        }
    });

    canvas.addEventListener('mouseup', e => {
        if (dragJob) {
            const snap = getGridSnap(dragJob.x, dragJob.y);
            
            if (snap && isValidPlacement(snap.c, snap.r, dragJob.w, dragJob.h)) {
                // Place Job
                dragJob.gridX = snap.c;
                dragJob.gridY = snap.r;
                dragJob.startTime = Date.now();
                activeJobs.push(dragJob);
            } else if (isOverTrash(e)) {
                // Cancel job: add 1s penalty to avg wait
                totalWaitPenaltyMs += 1000;
            } else {
                // Return to Queue
                // Add some randomness so they don't stack perfectly on top
                dragJob.x = 50 + (seededRand() * (CANVAS_WIDTH - 150));
                dragJob.y = QUEUE_Y + 50 + (seededRand() * 100);
                jobs.push(dragJob);
            }
            dragJob = null;
        }
    });

    // Node shop helpers
    function seededRand() {
        // LCG
        seed = (seed * 1664525 + 1013904223) >>> 0;
        return seed / 4294967296;
    }

    function seedFromString(str) {
        let h = 2166136261 >>> 0;
        for (let i = 0; i < str.length; i++) {
            h ^= str.charCodeAt(i);
            h = Math.imul(h, 16777619);
        }
        return h >>> 0;
    }

    function setSeed(newSeed, label = null) {
        seed = newSeed >>> 0;
        displaySeed = label !== null ? label : seed.toString();
        seedInput.value = displaySeed;
    }

    function applySeedFromInput() {
        const val = seedInput.value.trim();
        if (!val) return;
        const num = Number(val);
        if (!Number.isNaN(num)) {
            setSeed(num >>> 0, val);
        } else {
            setSeed(seedFromString(val), val);
        }
        // Reset randomness-driven pools for next round/shop
        shopItems = randomShopItems();
        renderShop();
        shopPreview = null;
    }

    function randomizeSeed() {
        const rnd = Math.floor(Math.random() * 1e9);
        setSeed(rnd, rnd.toString());
        shopItems = randomShopItems();
        renderShop();
        shopPreview = null;
    }

    function randomShopItems() {
        const items = [];
        while (items.length < 3) {
            const w = 1 + Math.floor(seededRand() * 4);
            const h = 1 + Math.floor(seededRand() * 4);
            const area = w * h;
            const cost = area * NODE_COST;
            items.push({ w, h, area, cost, id: `${Date.now()}-${items.length}` });
        }
        return items;
    }

    function renderShop() {
        shopItemsEl.innerHTML = '';
        shopItems.forEach(item => {
            const el = document.createElement('div');
            el.className = 'shop-item';
            el.style.background = '#1b1f2a';
            el.style.border = '1px solid #2c303a';
            el.style.borderRadius = '6px';
            el.style.padding = '8px';
            el.style.width = '90px';
            el.style.cursor = 'grab';
            el.style.color = '#fff';
            el.style.textAlign = 'center';
            el.dataset.itemId = item.id;
            const grid = document.createElement('div');
            grid.style.display = 'grid';
            grid.style.gridTemplateColumns = `repeat(${item.w}, 1fr)`;
            grid.style.gap = '2px';
            grid.style.marginTop = '6px';
            grid.style.justifyItems = 'center';
            grid.style.alignItems = 'center';
            grid.style.padding = '4px';
            grid.style.background = '#151821';
            for (let i = 0; i < item.w * item.h; i++) {
                const cell = document.createElement('div');
                cell.style.width = '14px';
                cell.style.height = '14px';
                cell.style.background = '#a3e4d7';
                cell.style.border = '1px solid #2c303a';
                cell.style.borderRadius = '2px';
                grid.appendChild(cell);
            }
            el.innerHTML = `<div style="font-weight:bold;">${item.w}x${item.h}</div><div style="color:#a9b1d6;font-size:12px;">Cost ${item.cost}g</div>`;
            el.appendChild(grid);
            el.addEventListener('mousedown', e => startDragShopItem(e, item));
            shopItemsEl.appendChild(el);
        });
    }

    function openShop(avgOcc = null, avgWait = null, bonus = null) {
        shopItems = randomShopItems();
        renderShop();
        shopModal.style.display = 'flex';
        shopPreview = null;
        const infoEl = document.getElementById('shop-info');
        if (avgOcc !== null) {
            infoEl.innerText = `Round complete. Occupancy: ${avgOcc}%. Avg wait: ${avgWait}s. Bonus: +${bonus}g. Seed: ${runSeedDisplay}. Drag a node to attach.`;
        } else {
            infoEl.innerText = `Drag a node to the cluster edge to attach. Cost: 10 gold per core. Seed: ${runSeedDisplay}.`;
        }
    }

    function closeShop() {
        shopModal.style.display = 'none';
    }

    function leaveShop() {
        closeShop();
        if (isGameOver && !gameLost) {
            startGame();
        }
    }

    function rerollShop() {
        if (gold < 10) {
            alert("Need 10 gold to reroll.");
            return;
        }
        gold -= 10;
        document.getElementById('gold').innerText = gold;
        shopItems = randomShopItems();
        renderShop();
        shopPreview = null;
    }

    function startDragShopItem(e, item) {
        shopModal.style.display = 'none';
        draggingShopItem = item;
        dragOffsetX = 0;
        dragOffsetY = 0;
        dragGhost = document.createElement('div');
        dragGhost.style.position = 'fixed';
        dragGhost.style.pointerEvents = 'none';
        dragGhost.style.background = '#7aa2f7aa';
        dragGhost.style.border = '1px dashed #fff';
        dragGhost.style.color = '#fff';
        dragGhost.style.padding = '4px 8px';
        dragGhost.style.borderRadius = '4px';
        dragGhost.style.fontSize = '12px';
        dragGhost.innerText = `${item.w}x${item.h} (${item.cost}g)`;
        document.body.appendChild(dragGhost);
        moveGhost(e);
        updateShopPreviewFromMouse(e);
        document.addEventListener('mousemove', onGhostMove);
        document.addEventListener('mouseup', endDragShopItem);
    }

    function moveGhost(e) {
        if (!dragGhost) return;
        dragGhost.style.left = `${e.clientX + 10}px`;
        dragGhost.style.top = `${e.clientY + 10}px`;
    }

    function onGhostMove(e) {
        moveGhost(e);
        updateShopPreviewFromMouse(e);
    }

    function getTrashRect() {
        return {
            x: CANVAS_WIDTH - TRASH_WIDTH - TRASH_MARGIN,
            y: CANVAS_HEIGHT - TRASH_HEIGHT - TRASH_MARGIN,
            w: TRASH_WIDTH,
            h: TRASH_HEIGHT
        };
    }

    function isOverTrash(e) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const t = getTrashRect();
        return mouseX >= t.x && mouseX <= t.x + t.w && mouseY >= t.y && mouseY <= t.y + t.h;
    }

    function updateShopPreviewFromMouse(e) {
        if (!draggingShopItem) return;
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left;
        const mouseY = e.clientY - rect.top;
        const snap = getGridSnap(mouseX, mouseY);
        if (!snap) {
            shopPreview = null;
            draw();
            return;
        }
        const valid = canPlaceNodeShape(snap.c, snap.r, draggingShopItem.w, draggingShopItem.h);
        shopPreview = { col: snap.c, row: snap.r, w: draggingShopItem.w, h: draggingShopItem.h, valid };
        draw();
    }

    function endDragShopItem(e) {
        document.removeEventListener('mousemove', onGhostMove);
        document.removeEventListener('mouseup', endDragShopItem);
        if (dragGhost) {
            dragGhost.remove();
            dragGhost = null;
        }
            if (!draggingShopItem) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;

        const testX = mouseX - GRID_OFFSET_X + (NODE_SIZE / 2);
        const testY = mouseY - GRID_OFFSET_Y + (NODE_SIZE / 2);
        const c = Math.floor(testX / NODE_SIZE);
        const r = Math.floor(testY / NODE_SIZE);

        if (!isNaN(c) && !isNaN(r) && canPlaceNodeShape(c, r, draggingShopItem.w, draggingShopItem.h)) {
            if (gold < draggingShopItem.cost) {
                alert("Not enough gold for that node.");
            } else {
                placeNodeShape(c, r, draggingShopItem.w, draggingShopItem.h);
                gold -= draggingShopItem.cost;
                document.getElementById('gold').innerText = gold;
            }
        }
        shopPreview = null;
        draw();
        if (isGameOver) {
            shopModal.style.display = 'flex';
        }
        draggingShopItem = null;
    }

    function rectsOverlap(a, b) {
        return (a.x < b.x + b.w &&
                a.x + a.w > b.x &&
                a.y < b.y + b.h &&
                a.y + a.h > b.y);
    }

    function isAdjacentToCluster(rect) {
        if (nodes.length === 0) return true;
        return nodes.some(n => {
            const touchingLeft = rect.x + rect.w === n.x && rect.y < n.y + n.h && rect.y + rect.h > n.y;
            const touchingRight = n.x + n.w === rect.x && rect.y < n.y + n.h && rect.y + rect.h > n.y;
            const touchingTop = rect.y + rect.h === n.y && rect.x < n.x + n.w && rect.x + rect.w > n.x;
            const touchingBottom = n.y + n.h === rect.y && rect.x < n.x + n.w && rect.x + rect.w > n.x;
            return touchingLeft || touchingRight || touchingTop || touchingBottom;
        });
    }

    function canPlaceNodeShape(col, row, w, h) {
        if (col < 0 || row < 0) return false;
        const newRect = {x: col, y: row, w, h};
        for (let n of nodes) {
            if (rectsOverlap(newRect, n)) return false;
        }
        return isAdjacentToCluster(newRect);
    }

    function placeNodeShape(col, row, w, h) {
        nodes.push({x: col, y: row, w, h});
        updateGridFromNodes();
        recomputeLayout();
        draw();
    }

    function endGame(avgOcc, avgWait) {
        const info = document.getElementById('gameover-info');
        info.innerText = `Score: ${totalGoldEarned}\nOccupancy: ${avgOcc}% | Avg wait: ${avgWait}s\nRounds reached: ${roundNumber}\nSeed: ${runSeedDisplay}`;
        document.getElementById('gameover-modal').style.display = 'flex';
    }

    closeShopBtn.addEventListener('click', leaveShop);

    // Initial render
    ctx.fillStyle = '#fff';
    ctx.font = '20px Courier New';
    ctx.fillText("Press START ROUND", (CANVAS_WIDTH / 2) - 100, CANVAS_HEIGHT / 2);

    // Responsive scaling on resize
    window.addEventListener('resize', () => {
        updateGridFromNodes();
        recomputeLayout();
        draw();
    });

</script>
</body>
</html>
